1.面向对象：
   面向对象是一种思想（一种开发的方式),面向对象是将具有共同特征的功能或者代码，
把它们归为一类（封装方法）,把它们需要详细描述的特性挂在原型上的一种编程方式。

2.js面向对象的特征：
抽象,封装,继承,多态

constructor 构造函数
3.new

new : 函数一元运算符。 专门用来运算的符号

        加了new不加括号依然调用，括号是拿来传参的。

        加了new之后构造中的this指向实例化对象

        默认return  this

        如果return 简单（基础）类型，那么返回值为实例化对象

        如果return 复合（复杂）类型，那么返回值为这个复合（复杂）类型。

4.原型：
  prototype，函数的一个属性，是解决性能问题的。

           *******  prototype的值是一个对象  ******

5.原型与原型链
  __proto__  原型链 :
           实例化对象与构造函数原型的桥梁
        __proto__ === 构造函数.prototype

对象没有原型只有原型链,而函数既有原型也有原型链，***构造函数的原型只给它的实例化对象使用***。

  一般面向对象都是把属性挂在构造函数中，
        把方法挂在构造函数的原型上。

6.this代表的值:window,触发事件的元素对象,undefined,父级,写啥是啥

7.箭头函数
var 变量=()=> 表达式  直接return 
var 变量=()=> {表达式;return 表达式} 
箭头函数表达式中的this永远和父级一样   *****箭头函数不能new不然要报错。*****
8.ES6:
            class Person{
                constructor(形参){
                    //一般初始化都放在这里。
                }
            }
            //函数
            {
                fn:function(){}
            }
            {
                fn(){

                }
            }

9.包装对象
非空对象下才能加属性或者方法.

        包装对象:
            当去调用简单类型的属性或者方法的时候，系统会偷偷地
           把简单类型转成复合类型，使用该对象的属性或者方法，之后
           又偷偷地销毁。

           简单类型的length只能读不能写。 


10.toString
只要使用alert那么它就会偷偷地调用toSting方法

        toSting -> 把xx类型转成string类型

        所有的类型都有toSting方法

        obj -> [object Object]  第二个Object代表系统构造函数是谁

        toSting()  还能转进制  -> var num = 10; num.toString(进制数)


11.call,apply,bind
修改this指向的方法  
        call:
            函数身上的一个方法，有若干的参数

            第一个参数：
                改变this指向

            第二个往后的参数：
                就是实参的个数。

        apply:
            只有2个参数

            第一个参数：
                改变this指向

            第二个参数:
                数组

        bind:
            修正this指向但是不直接调用，它会返回一个新的函数
            当调用新函数的时候会调出修改之后的this

            若干个参数:
                第一个参数：
                    改变this指向
                第二个往后的参数：
                    就是实参的个数。


12.forEach
forEach(function(值,索引,全部字符串或数组))

13.constructor:
            实例化对象上的一个属性：
                指向构造函数。

14.  instanceof :
            二元运算符

        实例化(对象)***  instanceof  构造函数

        左值是不是右值构造出来的  左值必须要为对象

        返回的是boolean值

15.obj.hasOwnProperty('属性名');
            是不是自身的属性:函数内的。

16.属性继承
 //属性的继承 -- 类式继承（构造继承）
//拷贝继承 //赋值 与 赋址

17.       深度克隆 -> deepClone

        因为一次遍历中如果对象里面的内容为简单类型，那么直接赋值即可（克隆成功）
        但是，如果在这个对象中还有对象类型，那么这个时候赋值即赋址。
        那这个时候碰到了对象类型就再遍历，遍历到全是简单类型为止,保证
        所有的赋值都是简单类型的赋值了，就达到了深度克隆的目的。

18.ES6变量
 变量:
            let
                在同域下不能多次声明一个变量名
                暂存死区（没有预解析），在变量的上方打印不出undefined，而是报错
                不会在window下创建这个变量。
        常量:(不可变的量，要变就报错)
            const
                在同域下不能多次声明一个变量名
                暂存死区（没有预解析），在变量的上方打印不出undefined，而是报错
                不会在window下创建这个变量。
                立即声明立即赋值使用